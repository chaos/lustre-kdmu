# vim:expandtab:shiftwidth=4:softtabstop=4:tabstop=4:

OLD_SCHOOL=true

RHBUILD=${RHBUILD:-0}
SUSEBUILD=${SUSEBUILD:-0}
LINUX26=${LINUX26:-0}
SUSEBUILD=${SUSEBUILD:-0}

build_tarball() {
    local TARGET=$1
    local SRPM=$2

    if [ "$TARGET" = "rhel-2.6" -o "$TARGET" = "rhel-2.4" ]; then
        local SPEC=""
        if [ "$TARGET" = "rhel-2.6" ]; then
            SPEC=kernel-2.6.spec
            OLDCONFIG=nonint_oldconfig
        elif [ "$TARGET" = "rhel-2.4" ]; then
            SPEC=kernel-2.4.spec
            OLDCONFIG=oldconfig
        fi

        RPMTOPDIR=$(mktemp -d $KERNELDIR/rpm_XXXXXX)
        mkdir $RPMTOPDIR/BUILD/
        rpm -ivh $KERNELDIR/$SRPM --define "_topdir $RPMTOPDIR" || \
            { rm -rf $RPMTOPDIR; fatal 1 "Error installing kernel SRPM."; }
        $RPMBUILD -bp --nodeps --target i686 $RPMTOPDIR/SPECS/$SPEC --define "_topdir $RPMTOPDIR" 2>&1
        pushd $RPMTOPDIR/BUILD/kernel-${lnxmaj}/linux-${lnxmaj} && {
            make mrproper
            cp configs/kernel-${lnxmaj}-i686-smp.config .config
            if ! make $OLDCONFIG > /dev/null; then
                fatal 1 "error trying to make $OLDCONFIG while building a tarball from SRPM."
            fi
            make include/linux/version.h
            rm -f .config
            cd ..
            tar cjf $KERNEL_FILE linux-${lnxmaj}
        }
        popd
        rm -rf $RPMTOPDIR
    fi
}

download_and_build_tarball() {
    local target=$1
    local kernel_file=$2

    local srpm=kernel-${lnxmaj}-${lnxrel}.src.rpm

    echo "Downloading http://downloads.lustre.org/public/kernels/$target/old/$srpm..."
    if ! wget -nv "http://downloads.lustre.org/public/kernels/$target/old/$srpm" \
        -O "$KERNELDIR/$srpm" ; then
        fatal 1 "Could not download target $kernel_file's kernel SRPM $srpm from downloads.lustre.org."
    fi
    [ -s "$KERNELDIR/$srpm" ] || {
        rm -rf $KERNELDIR/$srpm
        fatal 1 "Could not download target $kernel_file's kernel SRPM $srpm from downloads.lustre.org."
    }

    build_tarball $target $srpm
}

unpack_linux() {

    untar "$KERNEL_FILE" || fatal 1 "Error unpacking Linux tarball"
    [ -d linux ] || ln -sf linux* linux

}

patch_linux() {

    [ "$SERIES" ] || return 0

    do_patch_linux true

    echo "Replacing .config files..."
    [ -d linux/configs ] || mkdir linux/configs || \
        fatal 1 "Error creating configs directory."
    rm -f linux/configs/*
    copysuccess=0
    for patchesdir in "$EXTERNAL_PATCHES" "lustre/lustre/kernel_patches" ; do
        [ "$patchesdir" ] && \
            cp -v $patchesdir/kernel_configs/kernel-${VERSION}-${TARGET}*.config linux/configs/ >/dev/null && copysuccess=1
    done
    [ "$copysuccess" = "1" ] || \
        fatal 1 "Error copying in kernel configs."
}

pack_linux() {
    TARBALL="$(readlink linux)-$EXTRA_VERSION.tar.gz"
    echo "Creating patched linux tarball $TARBALL..."
    tar -zcf "$TARBALL" "$(readlink linux)" \
        --exclude "CVS" --exclude ".cvsignore" \
        --exclude "*.orig" --exclude "*~" --exclude "*.rej" || \
        fatal 1 "Error creating patched Linux tarball."
}

clean_linux() {
    [ -d linux ] || return 0
    echo "Cleaning linux..."
    [ -L linux ] && rm -rf $(readlink linux)
    rm -rf linux
}

prep_kernel_build() {
    local lmakeopts="\"\""
    if $XEN; then
        lmakeopts="--xen"
    fi
    # make .spec file
    ENABLE_INIT_SCRIPTS=""
    sed \
        -e "s^@BASE_ARCHS@^$BASE_ARCHS^g" \
        -e "s^@BIGMEM_ARCHS@^$BIGMEM_ARCHS^g" \
        -e "s^@BIGSMP_ARCHS@^$BIGSMP_ARCHS^g" \
        -e "s^@BOOT_ARCHS@^$BOOT_ARCHS^g" \
        -e "s^@CONFIGURE_FLAGS@^$CONFIGURE_FLAGS^g" \
        -e "s^@ENABLE_INIT_SCRIPTS@^$ENABLE_INIT_SCRIPTS^g" \
        -e "s^@JENSEN_ARCHS@^$BOOT_ARCHS^g" \
        -e "s^@KERNEL_EXTRA_VERSION@^$EXTRA_VERSION^g" \
        -e "s^@KERNEL_EXTRA_VERSION_DELIMITER@^$EXTRA_VERSION_DELIMITER^g" \
        -e "s^@KERNEL_TARGET_DELIMITER@^$TARGET_DELIMITER^g" \
        -e "s^@KERNEL_RELEASE@^${EXTRA_VERSION//-/_}^g" \
        -e "s^@KERNEL_SOURCE@^$KERNEL^g" \
        -e "s^@KERNEL_VERSION@^$VERSION^g" \
        -e "s^@LINUX26@^$LINUX26^g" \
        -e "s^@LUSTRE_SOURCE@^${LUSTRE##*/}^g" \
        -e "s^@LUSTRE_TARGET@^$TARGET^g" \
        -e "s^@PSERIES64_ARCHS@^$PSERIES64_ARCHS^g" \
        -e "s^@RHBUILD@^$RHBUILD^g" \
        -e "s^@SMP_ARCHS@^$SMP_ARCHS^g" \
        -e "s^@SUSEBUILD@^$SUSEBUILD^g" \
        -e "s^@UP_ARCHS@^$UP_ARCHS^g" \
        -e "s^@LMAKEOPTS@^$lmakeopts^g" \
        < $TOPDIR/lustre/build/lustre-kernel-2.4.spec.in \
        > lustre-kernel-2.4.spec
    [ -d SRPMS ] || mkdir SRPMS
    [ -d RPMS ] || mkdir RPMS
    [ -d BUILD ] || mkdir BUILD
    [ -d SOURCES ] || mkdir SOURCES
    for script in linux-{rhconfig.h,merge-config.awk,merge-modules.awk} \
        suse-{functions.sh,post.sh,postun.sh,trigger-script.sh.in} \
        sles8-{pre,post,postun,update_{INITRD_MODULES,rcfile_setting}}.sh ; do
        cp $TOPDIR/lustre/build/$script SOURCES
    done
    cp "$LUSTRE" "$KERNEL_FILE" SOURCES
    if [ "$EXTERNAL_PATCHES" -a -d "$EXTERNAL_PATCHES" ] ; then
        tar zcf SOURCES/external-patches.tar.gz -C "$EXTERNAL_PATCHES" series targets patches kernel_configs
    else
        touch SOURCES/external-patches.tar.gz
    fi
}

clean_lustre() {
    [ -d lustre ] || return 0
    echo "Cleaning Lustre..."
    [ -L lustre ] && rm -rf $(readlink lustre)
    rm -rf lustre
}

build_kernel() {
    echo "Building kernel + Lustre RPMs for: $BUILD_ARCHS..."
    targets=
    for arch in $BUILD_ARCHS ; do
        targets="--target $arch $targets"
    done

    local rpmbuildopt='-bb'
#    if $NORPM; then
#        rpmbuildopt='-bc'
#        echo NORPM mode. Only compiling.
#        echo "XXX: need to fix lmake - add options to do rpmbuild -bc instead of -bb"
#    fi

    $RPMBUILD $targets $rpmbuildopt lustre-kernel-2.4.spec \
        --define "_tmppath $TMPDIR" \
        --define "_topdir $TOPDIR" 2>&1 || \
        fatal 1 "Error building rpms for $BUILD_ARCHS."

    if $DO_SRC; then
        $RPMBUILD -bs lustre-kernel-2.4.spec \
            --define "_tmppath $TMPDIR" \
            --define "_topdir $TOPDIR" 2>&1 || \
            fatal 1 "Error building .src.rpm."
    fi

    ( $(skeep_ldiskfs_rpm $TAG) ) && return

    pushd $TOPDIR/BUILD/lustre*/ldiskfs || return 255
    make dist
    if [ "$?" != "0" ] ; then
        popd
        return 255
    fi
    cp lustre-ldiskfs*.tar.gz $TOPDIR/SOURCES

    gen_lustre_version

    local ldiskfs_spec=lustre-ldiskfs.spec
    [ -f "$ldiskfs_spec" ] && sed \
    -e "s^Release: .*$^Release: $LUSTRE_EXTRA_VERSION^" \
    < $ldiskfs_spec \
    > ../lustre-ldiskfs.spec

    if ! $RPMBUILD $targets $rpmbuildopt ../lustre-ldiskfs.spec \
                   --define "_tmppath /var/tmp" \
                   --define "_topdir $TOPDIR" 2>&1; then
        popd
        return 255
    fi

    if $DO_SRC; then
            if ! $RPMBUILD -bs ../lustre-ldiskfs.spec \
                           --define "_tmppath /var/tmp" \
                           --define "_topdir $TOPDIR" 2>&1; then
            popd
            return 255
        fi
    fi
    popd
}

#get date of last changed target/config/series/patches
get_last_source_date() {
    local filelist="${TOPDIR}/lustre/lustre/kernel_patches/series/${SERIES} \
        $CONFIG_FILE"
    local TOPDIRnew=$(echo ${TOPDIR} | sed -e s/\\//\\\\\\//g)
    filelist="$filelist $( \
        cat ${TOPDIR}/lustre/lustre/kernel_patches/series/${SERIES} | \
        sed -e s/^/${TOPDIRnew}\\/lustre\\/lustre\\/kernel_patches\\/patches\\// 2>&1)"
    local sourcelastdate=$( find ${filelist} -name CVS -prune -o \
                -type f -printf "%T@\n" 2>&1 | sort | tail -1 )
    is_integer $sourcelastdate && echo $sourcelastdate
}

#check if variable is integer
is_integer() {
    local invariable=$1
    [ "$invariable" = "" ] && return 255
    local invariableint=$( echo $invariable | sed -e s/[^0-9]//g )
    [ "$invariable" = "$invariableint" ] || return 255
}

#store RPMs and/or BUILD dir for future reuse
store_for_reuse() {
    local rpmonly=$1
    if [ ! "$REUSEBUILD" = "" ] && [ -d  "/$REUSEBUILD/" ] ; then
        [ -d "${REUSEBUILD}/${TIMESTAMP}" ] || mkdir "${REUSEBUILD}/${TIMESTAMP}"
        [ -d "${REUSEBUILD}/${TIMESTAMP}" ] || return 255
    else
        return 255
    fi

    local lnxrelnew=${lnxrel//-/_}
    local EXTRA_VERSIONnew=${EXTRA_VERSION//-/_}
    local KERNELRPMnew=$(basename "$KERNELRPM")
    if [ ! "$rpmonly" = "rpmonly" ]; then
	    local builddir=
        if [ ! "$KERNELCOMPILEDIR" = "" ]; then
            builddir="$KERNELCOMPILEDIR"
        else
            builddir="BUILD/lustre-kernel-${lnxmaj}/lustre/linux-${lnxmaj}"
	    [ "$KERNELCOMPILEDIR" = "" ] || builddir="$KERNELCOMPILEDIR"
            [ -d "$builddir" ] || builddir="BUILD/lustre-kernel-${lnxmaj}/lustre/linux-${lnxmaj}.${lnxrel}"
            [ -d "$builddir" ] || builddir="BUILD/lustre-kernel-${lnxmaj}/lustre/linux-${lnxmaj}-${lnxrel}"
	    if [ ! -d "$builddir" ]; then
                pushd "BUILD/lustre-kernel-${lnxmaj}/lustre/" || return 255
                local basebuilddir=$(ls -d linux-${lnxmaj}* | head -1)
                [ "$basebuilddir" = "" ] || builddir="BUILD/lustre-kernel-${lnxmaj}/lustre/${basebuilddir}"
                popd
	    fi
        fi
        [ -d "$builddir" ] || return 255
	local dstdir="${REUSEBUILD}/${TIMESTAMP}/linux-${KERNCONFSMPTYPE}-${lnxmaj}-${EXTRA_VERSIONnew}.${TARGET_ARCH}"
	( $PATCHLESS ) && dstdir="${REUSEBUILD}/${TIMESTAMP}/linux-$KERNELRPMnew" && \
	        dstdir="${dstdir%.rpm}"
	[ -d "$dstdir" ] && rm -rf "$dstdir"
        mv "${builddir}" "$dstdir" || return 255
        if [ -n "$OFED_VERSION" -a "$OFED_VERSION" != "inkernel" ]; then
            # move the OFED kernel-ib-devel tree as well
            mv "${builddir%/*}/kernel-ib-devel/usr/src/ofa_kernel" "${dstdir%/*}" || return 255
        fi
    fi
    #store kernel rpm
    local kernelrpmname="kernel-lustre-${KERNCONFSMPTYPE}-${lnxmaj}-${EXTRA_VERSIONnew}.${TARGET_ARCH}.rpm"
    [ -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" ] || kernelrpmname="kernel-${KERNCONFSMPTYPE}-${lnxmaj}-${EXTRA_VERSNnew}.${TARGET_ARCH}.rpm"
    ( $PATCHLESS ) && [ -f "$KERNELRPM" ] && kernelrpmname="$KERNELRPMnew"
    if [ "$rpmonly" = "rpmonly" ] && [ -f "${REUSEBUILD}/${TIMESTAMP}/${kernelrpmname}" ]; then
        echo "RPM already exist in store directory tree"
    else
        [ -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" ] && cp -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" "${REUSEBUILD}/${TIMESTAMP}/"
    fi
    #store kernel source rpm
    kernelrpmname="kernel-lustre-source-${lnxmaj}-${EXTRA_VERSIONnew}.${TARGET_ARCH}.rpm"
    [ -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" ] || kernelrpmname="kernel-source-${lnxmaj}-${EXTRA_VERSIONnew}.${TARGET_ARCH}.rpm"
    ( $PATCHLESS ) && [ -f "$KERNELSOURCERPM" ] && kernelrpmname=$(basename "$KERNELSOURCERPM")
    if [ "$rpmonly" = "rpmonly" ] && [ -f "${REUSEBUILD}/${TIMESTAMP}/${kernelrpmname}" ]; then
        echo "RPM already exist in store directory tree"
    else
	    [ -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" ] && cp -f "RPMS/${TARGET_ARCH}/${kernelrpmname}" "${REUSEBUILD}/${TIMESTAMP}/"
    fi
    if [ -n "$OFED_VERSION" -a "$OFED_VERSION" != "inkernel" ]; then
        # store kernel-ib RPMs
        local rpmname
        local ofed_version=$(echo $OFED_VERSION |
                             sed -re 's/-(20[0-9]{6,6}-[0-9]{4,4}|rc[0-9]*)$//')
        for rpmname in "kernel-ib" "kernel-ib-devel"; do
            rpmname="${rpmname}-${ofed_version}"
            if $PATCHLESS; then
                rpmname="${rpmname}-${LINUXRELEASE//-/_}"
            else
                rpmname="${rpmname}-${lnxmaj}${EXTRA_VERSION_DELIMITER//-/_}${EXTRA_VERSIONnew}${TARGET_DELIMITER//-/_}${KERNCONFSMPTYPE}"
            fi
            rpmname="${rpmname}.${TARGET_ARCH}.rpm"
            if [ "$rpmonly" = "rpmonly" ] && [ -f "${REUSEBUILD}/${TIMESTAMP}/${rpmname}" ]; then
                echo "RPM already exist in store directory tree"
            else
                [ -f "RPMS/${TARGET_ARCH}/${rpmname}" ] && cp -f "RPMS/${TARGET_ARCH}/${rpmname}" "${REUSEBUILD}/${TIMESTAMP}/"
            fi
        done
    fi
}

#look for kernel source RPM
find_linux_source_rpm() {
    local rpmfile=
    local findarch=true
    local arch=
    local pathtorpms=
    [ ! "$TARGET_ARCH" = "" ] && arch=$TARGET_ARCH && findarch=false
    
    if ! $findarch; then
        pathtorpms="${KERNELRPMSBASE}/${lnxmaj}/${DISTRO}/${arch}"
        [ -d $pathtorpms ] || return 255
        case "$DISTRO" in
            rhel4)
                rpmfile="kernel-${lnxmaj}-${lnxrel}.src.rpm"
            ;;
            sles10)
                rpmfile="kernel-source-${lnxmaj}.${lnxrel}.${arch}.rpm"
            ;;
            *)
                rpmfile="kernel-source-${lnxmaj}-${lnxrel}.${arch}.rpm"
            ;;
        esac
        [ -f "${pathtorpms}/${rpmfile}" ] || return 255
        KERNELSOURCERPM="${pathtorpms}/${rpmfile}"
    else
        for arch in $TARGET_ARCHS_ALL; do
        pathtorpms="${KERNELRPMSBASE}/${lnxmaj}/${DISTRO}/${arch}"
        [ -d $pathtorpms ] || continue
        case "$DISTRO" in
            rhel4)
                rpmfile="kernel-${lnxmaj}-${lnxrel}.src.rpm"
            ;;
            sles10)
                rpmfile="kernel-source-${lnxmaj}.${lnxrel}.${arch}.rpm"
            ;;
            *)
                rpmfile="kernel-source-${lnxmaj}-${lnxrel}.${arch}.rpm"
            ;;
        esac
        [ -f "${pathtorpms}/${rpmfile}" ] || continue
        KERNELSOURCERPM="${pathtorpms}/${rpmfile}"
        TARGET_ARCH=${arch}
        break
        done
    fi
    [ -f "${KERNELSOURCERPM}" ] || return 255
}

#unpack and make symlinks for reusing kernel RPM
reuse_kernel_rpm() {
    local pathtorpm=$1
    local pathtokernelibrpm=$2
    [ "$pathtorpm" = "" ] && return 255
    [ -f "$pathtorpm" ] || return 255
    [ -d $TOPDIR/reused ] || mkdir $TOPDIR/reused
    pushd $TOPDIR/reused || return 255

    rpm2cpio < $pathtorpm | cpio -idc
    [ ${PIPESTATUS[0]} -eq 0 ] || return 255

    if [ -n "$pathtokernelibrpm" ] && [ -f "$pathtokernelibrpm" ]; then
        rpm2cpio < $pathtokernelibrpm | cpio -idc
        [ ${PIPESTATUS[0]} -eq 0 -o ${PIPESTATUS[1]} -eq 0 ] || return 255
        CONFIGURE_FLAGS="--with-o2ib=$(pwd)/usr/src/ofa_kernel ${CONFIGURE_FLAGS}"
    fi

    local smptype=
    if pushd usr/src/linux-*-obj/${TARGET_ARCH}; then
        local smptypes="$SMPTYPES"
        [ "$RPMSMPTYPE" = "" ] || smptypes=$RPMSMPTYPE
        ( ! $PATCHLESS ) && [ ! "$KERNCONFSMPTYPE" = "" ] && smptypes="$KERNCONFSMPTYPE"
        local cursmptype=
        for cursmptype in $smptypes; do
            [ "$cursmptype" = "''" ] && continue
            [ -d $cursmptype ] && smptype=$cursmptype
            [ -d $smptype ] && break
        done
        popd
    fi
    if [ "${smptype}" = "" ]; then
        popd
        return 255 # cannot detect smp type
    fi
    if pushd usr/src/linux-*-obj/${TARGET_ARCH}/$smptype/include2; then
        local base=$(readlink asm)
        if [ ! -d "/${base}/" ]; then
            rm -f asm
            base=$(basename "$base")
            if pushd ../../../../linux-*/include; then
                local lsrc=$(pwd)
                popd
                [ -d "$lsrc/${base}" ] && ln -s $lsrc/${base} asm
            fi
        fi
        popd
        read a b < <(echo $(pwd)/usr/src/linux-*)
        if [[ $a == $(pwd)/* && $b = $(pwd)/* ]]; then
            cp -f $a/include/linux/config.h $b/${TARGET_ARCH}/$smptype/include/linux/
            cp $b/${TARGET_ARCH}/$smptype/.config $a/
            [ -f "$b/${TARGET_ARCH}/$smptype/.config" ] && KERNELRPMCONFIG="$b/${TARGET_ARCH}/$smptype/.config"
            cp $b/${TARGET_ARCH}/$smptype/.kernelrelease $a/
            [ -f "$b/${TARGET_ARCH}/$smptype/.kernelrelease" ] && KERNELRPMRELEASE="$b/${TARGET_ARCH}/$smptype/.kernelrelease"
            LINUX=$a
            LINUXOBJ=$b/${TARGET_ARCH}/$smptype
#            local fname=$(basename $kernel_rpm)
#            KERNELRPMSDIR=${kernel_rpm%$fname}
        fi
    fi
    popd
    [ "$LINUX" = "" ] && return 255
    [ -d "$LINUX" ] || return 255
}

#build linux kernel rpm
build_linux_rpm() {
    pushd $LINUX || return 255
    make binrpm-pkg || ( popd ; return 255 )
    local addlnxrel=
    [ -f ".version" ] && addlnxrel="-$(cat .version)"
    popd
    local arch=
    for arch in $TARGET_ARCHS_ALL; do
        [ -f "/usr/src/rpm/RPMS/$arch/kernel-$lnxmaj.${lnxrel}${addlnxrel}.$arch.rpm" ] && \
            KERNELRPM="/usr/src/rpm/RPMS/$arch/kernel-$lnxmaj.${lnxrel}${addlnxrel}.$arch.rpm" && \
            TARGET_ARCH="$arch"
        [ -f "/usr/src/packages/RPMS/$arch/kernel-$lnxmaj.${lnxrel}${addlnxrel}.$arch.rpm" ] && \
            KERNELRPM="/usr/src/packages/RPMS/$arch/kernel-$lnxmaj.${lnxrel}${addlnxrel}.$arch.rpm" && \
            TARGET_ARCH="$arch"
    done
    [ "$KERNELRPM" = "" ] || return
    return 255
}

#build linux kernel
build_linux() {
    local nofullmake=$1
    local nocopykernel=$2
    pushd $LINUX || fatal 1 "Kernel source not found"
    [ "$nofullmake" = "nofullmake" ] || make mrproper
    [ "$nofullmake" = "nofullmake" ] || rm -f rpm-release
#    [ "$nocopykernel" = "copyrpmkernel" ] || rm -f localversion-*
    [ "$nocopykernel" = "copykernel" ] && [ -f "$CONFIG_FILE" ] && cp $CONFIG_FILE .config
    if [ "$nocopykernel" = "copyrpmkernel" ]; then
        [ -f "$KERNELRPMCONFIG" ] && cp $KERNELRPMCONFIG .config
        if [ -f "$KERNELRPMRELEASE" ]; then
            cp $KERNELRPMRELEASE .
        else
            sed -e "s/^EXTRAVERSION\s\+=\s\+.*$/EXTRAVERSION = -${lnxrel}/" < Makefile > Makefile.new
            [ -f "Makefile.new" ] && mv Makefile.new Makefile
        fi
    fi
    [ -f ".config" ] || ( popd ; echo "Cannot find .config file"; return 255 )
    make oldconfig || ( popd ; return 255 )
    make include/linux/version.h
    if [ ! "$nofullmake" = "nofullmake" ]; then
        make || ( popd ; return 255 )
    fi
    popd
    return
}

#build patchless lustre
patchless_build_sequence() {
    if [ -f $LINUX/Makefile ]; then
        # Get the correct kernel release - I'm unsure how this can ever
        # work otherwise, unless you're using the exact same kernel version
        # Lustre is shipped with.

        local LINUXRELEASE=$(find_linux_release ${LINUXOBJ:-$LINUX})
        if [ -z "$LINUXRELEASE" ]; then
            echo "Failed to find linux release in ${LINUXOBJ:-$LINUX}"
            RC=255
        fi

	lnxmaj=$(echo $LINUXRELEASE | cut -f1 -d-)
	EXTRA_VERSION=$(echo $LINUXRELEASE | cut -f2 -d-)_lustre.$LUSTRE_VERSION
        RPMSMPTYPE=" "
        build_lustre && buildsuccess=true
    else
    #try to build from kernel-devel RPM (RHEL)
    LINUX=
    TARGET_ARCH=
    local rpmfound=false
    local buildsuccess=false
    local storeforreuse=false
    if [ "$KERNELRPMSBASE" = "" ] || [ ! -d "$KERNELRPMSBASE" ]; then
        return 255
    fi
    [ -d $TOPDIR/reused ] && rm -rf $TOPDIR/reused

    local delimiter=${EXTRA_VERSION_DELIMITER:-"-"}

    # default to source type -source and special case below
    local type=-source
    case "$DISTRO" in
        rhel*)
            type=-devel
            ;;
    esac

    local kernel_devel_rpm

    if ! kernel_devel_rpm=$(find_linux_rpm "$type" "$delimiter"); then
        fatal 1 "Could not find the kernel$type RPM in ${KERNELRPMSBASE}/${lnxmaj}/${DISTRO}"
    fi

    # find_linux_rpm() used to set these globals, but now it's a function
    # run in a subshell so it's unable to set globals in our namespace
    TARGET_ARCH=$(rpm -q --queryformat "%{ARCH}" -p "$kernel_devel_rpm")
    BUILD_ARCHS="$TARGET_ARCH"

    unpack_linux_devel_rpm "$kernel_devel_rpm" "$delimiter" && rpmfound=true

    [ -d SRPMS ] || mkdir SRPMS
    [ -d RPMS ] || mkdir RPMS
    [ -d BUILD ] || mkdir BUILD
    [ -d SOURCES ] || mkdir SOURCES

    # first build kernel-ib
    if [ -n "$OFED_VERSION" -a "$OFED_VERSION" != "inkernel" ]; then
        $rpmfound && build_kernel_ib
    fi
    ( $rpmfound ) && build_lustre && buildsuccess=true && find_linux_source_rpm
    fi

    if $buildsuccess; then
        [ -d "RPMS/${TARGET_ARCH}" ] && [ -f "$KERNELRPM" ] && \
            cp "$KERNELRPM" RPMS/${TARGET_ARCH}/
        [ -d "RPMS/${TARGET_ARCH}" ] && [ -f "$KERNELSOURCERPM" ] && \
            cp "$KERNELSOURCERPM" RPMS/${TARGET_ARCH}/
        KERNELCOMPILEDIR="$LINUX"
        if $storeforreuse; then
            store_for_reuse || echo "Cannot store for future reuse"
        fi

        return
    elif ! $rpmfound; then
        echo "COULD NOT FIND VENDOR -devel or -source RPM for $DISTRO/$TARGET_ARCH: $lnxmaj-$lnxrel in $KERNELRPMSBASE"
        return 255
    else
        echo "Patchless build failed."
        return 255
    fi
}

#check timestamp value. should bi 14-digits string
check_timestamp() {
    local invalue=$1
    local timestampnodig=$(echo $invalue | sed -e s/[0-9]*//g)
    [ "$timestampnodig" = "" ] || return 255
    local timestamplength="${#invalue}"
    [ $timestamplength -eq 14 ] || return 255
}

# get list of suitable directories with potential reused staff
get_reuse_dir_list() {
    local rpmonly=$1
    local reusedkernelmasknew=$2
    local buildtimestamp=
    local dirsforreuse=
    local sourcelastdate=$(get_last_source_date)
    for buildtimestamp in $(ls "$REUSEBUILD/" 2>&1); do
        [ -d "$REUSEBUILD/$buildtimestamp" ] || continue
	check_timestamp "$buildtimestamp" || continue
        local buildtimestampstr=$(echo $buildtimestamp | \
            sed -e "s^\(....\)\(..\)\(..\)\(..\)\(..\)\(..\)^\1-\2-\3 \4:\5:\6 GMT^g")
        local buildtimestampepoch=$(date --date="$buildtimestampstr"  +%s )
        #check for suitable date
	    if ! $PATCHLESS; then
            [ $buildtimestampepoch -ge $sourcelastdate ] || continue
	    fi
        #check for suitable version
        if [ "$rpmonly" = "rpmonly" ]; then
            local reusedkernelprefix="kernel-lustre-"
            ( $PATCHLESS ) && reusedkernelprefix=
            local rpmmask="${reusedkernelprefix}${REUSEDKERNELMASK}"
            [ "$reusedkernelmasknew" = "" ] || rpmmask="$reusedkernelmasknew"
            [ -f $REUSEBUILD/$buildtimestamp/${rpmmask}.rpm ] && \
                dirsforreuse="$dirsforreuse $REUSEBUILD/$buildtimestamp"
        else
            local rpmmask="$REUSEDKERNELMASK"
            [ "$reusedkernelmasknew" = "" ] || rpmmask="$reusedkernelmasknew"
            pushd $REUSEBUILD/$buildtimestamp/linux-${rpmmask} > /dev/null 2>&1 || continue
            local curdir=$(pwd)
            dirsforreuse="$dirsforreuse $curdir"
            popd
        fi
    done
    echo "$dirsforreuse"
}

#try to reuse old RPM
build_sequence_rpm_reuse() {
    local sourcerpm=$1
    [ "$REUSERPM" = "" ] && [ "$REUSEBUILD" = "" ] && return 255
    local dirsforreuse=
    if ! [ "$REUSEBUILD" = "" ] && [ -d "$REUSEBUILD" ]; then #try to reuse RPM
        local REUSEDKERNELMASKnew=$(echo $REUSEDKERNELMASK | sed -e "s/^[^0-9]*//")
        REUSEDKERNELMASKnew="kernel-lustre-source-${REUSEDKERNELMASKnew}"
        local dirsforreuse="$(get_reuse_dir_list rpmonly $REUSEDKERNELMASKnew)"
        local buildsuccess=false
        LINUXOBJ=
        for curdir in $(echo $dirsforreuse); do
            [ -d "$curdir" ] || continue
            local reusedkernelprefix="kernel-lustre-"
            local reusedkernelrpm=
            [ -f ${curdir}/${reusedkernelprefix}${REUSEDKERNELMASK}.rpm ] && \
                reusedkernelrpm=$(ls ${curdir}/${reusedkernelprefix}${REUSEDKERNELMASK}.rpm | head -1 )
            [ -f "$reusedkernelrpm" ] || continue

            local reusedkernelsourcerpm=
            [ -f ${curdir}/${REUSEDKERNELMASKnew}.rpm ] && \
                reusedkernelsourcerpm=$(ls ${curdir}/${REUSEDKERNELMASKnew}.rpm | head -1 )
            [ -f "$reusedkernelsourcerpm" ] || continue

            # don't need to check for kernel-ib RPM reuse here because sles9 is not supported
            # by OFED >= 1.3.0 and this function appears to only be used for sles9

            [ -d $TOPDIR/reused ] && rm -rf $TOPDIR/reused
            reuse_kernel_rpm "$reusedkernelsourcerpm" "" && build_linux nofullmake copyrpmkernel && build_lustre && buildsuccess=true
            ( $buildsuccess ) || continue
            if ( ! $NORPM ) && ( ! $PATCHLESS ) ; then
                [ -f "$reusedkernelrpm" ] && \
                    cp -f  "$reusedkernelrpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1

                [ -f "$reusedkernelsourcerpm" ] && \
                    cp -f  "$reusedkernelsourcerpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1 && \
                    touch RPMS/${TARGET_ARCH}/kernel_was_reused
            fi
            return
        done
    fi
    return 255
}

#try to reuse old BUILD dir
build_sequence_reuse() {
    local sourcerpm=$1
    [ "$REUSERPM" = "" ] && [ "$REUSEBUILD" = "" ] && return 255
    local dirsforreuse=
    if [ ! "$REUSEBUILD" = "" ] && [ -d "$REUSEBUILD" ]; then #try to reuse old kernel build directory
        local dirsforreuse="$(get_reuse_dir_list)"
        local buildsuccess=false
        LINUXOBJ=
        local REUSEDKERNELMASKnew=$(echo $REUSEDKERNELMASK | sed -e "s/^[^0-9]*//")
        for curdir in $(echo $dirsforreuse); do
            local reusedkernelrpm=
            local reusedkernelsourcerpm=
            local reusedkernelibrpm=
            [ -d "$curdir" ] || continue
            [ -n "$OFED_VERSION" -a "$OFED_VERSION" != "inkernel" -a 
	      ! -d "${curdir%/*}/ofa_kernel" ] && continue
            local reusedkernelprefix="kernel-lustre-"
            ( $PATCHLESS ) && reusedkernelprefix=
            [ -f ${curdir}/../${reusedkernelprefix}${REUSEDKERNELMASK}.rpm ] && \
                reusedkernelrpm=$(ls ${curdir}/../${reusedkernelprefix}${REUSEDKERNELMASK}.rpm | head -1 )
            reusedkernelprefix="kernel-lustre-source-"
            [ -f ${curdir}/../${reusedkernelprefix}${REUSEDKERNELMASKnew}.rpm ] && \
                reusedkernelsourcerpm=$(ls ${curdir}/../${reusedkernelprefix}${REUSEDKERNELMASKnew}.rpm | head -1 ) 
            if [ -n "$OFED_VERSION" -a "$OFED_VERSION" != "inkernel" ]; then
                gen_lustre_version
                reusedkernelprefix="kernel-ib-"
                [ -f ${curdir}/../${reusedkernelprefix}${OFED_VERSION}-${LUSTRE_EXTRA_VERSION}.${TARGET_ARCH}.rpm ] && \
                    reusedkernelibrpm=$(ls ${curdir}/../${reusedkernelprefix}${OFED_VERSION}-${LUSTRE_EXTRA_VERSION}.${TARGET_ARCH}.rpm | head -1 ) 
                    reusedkernelibdevelrpm=$(ls ${curdir}/../${reusedkernelprefix}devel-${OFED_VERSION}-${LUSTRE_EXTRA_VERSION}.${TARGET_ARCH}.rpm | head -1 ) 
            fi
            if ! ( $NORPM ) && ! [ -f "$reusedkernelrpm" ]; then #kernel rpm not found. Build all
                continue
            fi
            if ! ( $NORPM ) && ! [ -f "$reusedkernelsourcerpm" ]; then #kernel source rpm not found. Build all
                continue
            fi
            if [ -n "$OFED_VERSION" ]; then
                if [ "$OFED_VERSION" != "inkernel" ]; then
                    if ! ( $NORPM ) && [ ! -f "$reusedkernelibrpm" -o ! -f "$reusedkernelibdevelrpm"]; then #kernel-ib{,-devel} rpm not found. Build all
                        continue
                    fi
                    CONFIGURE_FLAGS="--with-o2ib=${curdir%/*}/ofa_kernel ${CONFIGURE_FLAGS}"
                else
                    CONFIGURE_FLAGS="--with-o2ib=yes ${CONFIGURE_FLAGS}"
		fi
            fi
            LINUX="$curdir"
            build_lustre || continue
            touch "$curdir/../"
            buildsuccess=true
            if ( ! $NORPM ) && ( ! $PATCHLESS ) ; then
                [ -f "$reusedkernelrpm" ] && \
                    cp -f  "$reusedkernelrpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1 && \
                    touch RPMS/${TARGET_ARCH}/kernel_was_reused
                [ -f "$reusedkernelsourcerpm" ] && \
                    cp -f  "$reusedkernelsourcerpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1
                [ -f "$reusedkernelibrpm" ] && \
                    cp -f  "$reusedkernelibrpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1
                    cp -f  "$reusedkernelibdevelrpm"  RPMS/${TARGET_ARCH}/ > /dev/null 2>&1
            fi
            return
        done
    fi
    return 255
}

build_sequence() {
    if $DO_SRC; then
        unpack_linux
        patch_linux
        pack_linux
        clean_linux
    fi
    prep_kernel_build || return 255
    clean_lustre || return 255

    build_kernel || return 255
}

old_school_download_kernel() {

    if [ "$KERNELDIR" ] ; then
        KERNEL_FILE="$KERNELDIR/$KERNEL"
        if [ ! -r "$KERNEL_FILE" ] ; then
            # see if we have an SRPM we can build a tarball for
            KERNEL_SRPM=kernel-${lnxmaj}-${lnxrel}.src.rpm
            if [ -r "$KERNELDIR/$KERNEL_SRPM" ] ; then
                build_tarball $CANONICAL_TARGET $KERNEL_SRPM
            else
                if $DOWNLOAD; then
                    echo "Downloading http://downloads.lustre.org/public/kernels/$DISTRO/old/$KERNEL..."
                    if ! wget -nv "http://downloads.lustre.org/public/kernels/$DISTRO/old/$KERNEL" -O "$KERNELDIR/$KERNEL" ; then
                        # see if we can do it with an SRPM from the download site
                        download_and_build_tarball $CANONICAL_TARGET $KERNEL_FILE
                    else
                        [ -s "$KERNELDIR/$KERNEL" ] || {
                            rm -rf "$KERNELDIR/$KERNEL"
                            fatal 1 "Target $TARGET's kernel $KERNEL not found in directory $KERNELDIR."
                        }
                    fi
                else
                    fatal 1 "Target $TARGET's kernel file $KERNEL not found in kernel directory $KERNELDIR."
                fi
            fi
        fi
    fi
}
